import os
import argparse
import pdfplumber
import re
import psycopg
from datetime import datetime
import uuid


def format_date(str_date):
    return datetime.strptime(str_date, "%d/%m/%Y").strftime("%Y-%m-%d")


def parse_args():
    arg_parser = argparse.ArgumentParser()

    arg_parser.add_argument("--type", "-t", required=True, help="Options: edf")

    arg_parser.add_argument("file", help="Path to the file to process")

    args = arg_parser.parse_args()

    print(f"Args detected: type={args.type} file={args.file}")

    return args


# This is a function generated by ChatGPT that is able to add the missing spaces in the PDF
# This resolves the issue of reading the pdf, which removes all spaces
def extract_with_inferred_spaces(page_region, gap_ratio=0.3):
    chars = page_region.chars
    if not chars:
        return ""

    # Group chars by text line (y position)
    lines = {}
    for c in chars:
        y = round(c["top"], 1)
        lines.setdefault(y, []).append(c)

    output_lines = []
    for y in sorted(lines):
        line_chars = sorted(lines[y], key=lambda x: x["x0"])
        line = ""
        for i, cur in enumerate(line_chars):
            line += cur["text"]
            if i + 1 < len(line_chars):
                nxt = line_chars[i + 1]
                gap = nxt["x0"] - cur["x1"]
                avg_width = cur["x1"] - cur["x0"]
                if gap > avg_width * gap_ratio:
                    line += " "
        output_lines.append(line)

    return "\n".join(output_lines)


def parse_pdf(type, file):
    file_content = ""

    def get_left_panel_info(page):
        left_panel = page.crop((20, 0, page.width * 0.30, page.height))

        panel_text = extract_with_inferred_spaces(left_panel)

        # address
        address = panel_text.split("Lieu de consommation\n")[1].split(
            "\nTitulaire du contrat"
        )[0]

        # client_name
        client_name = re.sub(
            r"(Mlle|Mr|Mme) ",
            "",
            panel_text.split("Titulaire du contrat\n")[1].split("\nVotre contrat")[0],
        )

        # client_number
        client_number = (
            panel_text.split("N° de client : ")[1]
            .split("\nN° de compte : ")[0]
            .replace(" ", "")
        )

        # account_number
        account_number = (
            panel_text.split("N° de compte : ")[1].split("\n")[0].replace(" ", "")
        )

        # contract_type
        contract_type = panel_text.split('Electricité "')[1].split('"')[0]

        # delivery_point_number
        delivery_point_number = (
            panel_text.split("Point de livraison (PDL) :\nN° ")[1]
            .split("\n")[0]
            .replace(" ", "")
        )

        # power_kva
        power_kva = float(
            panel_text.split("Puissance : ")[1].split(" kVA\n")[0].replace(" ", "")
        )

        # off_peak_hours
        off_peak_hours = panel_text.split("Option Heures Pleines/Heures Creuses\n")[1]

        return {
            "address": address,
            "client_name": client_name,
            "client_number": client_number,
            "account_number": account_number,
            "contract_type": contract_type,
            "delivery_point_number": delivery_point_number,
            "power_kva": power_kva,
            "off_peak_hours": off_peak_hours,
        }

    def get_bill_period_info(str_start, file_content, bill_id):
        substring = file_content[str_start.start() :]

        # start_index_off_peak
        start_index_off_peak_match = re.search(r"Heurescreuses (\d+) \d+", substring)

        start_index_off_peak = (
            start_index_off_peak_match.group(1) if start_index_off_peak_match else None
        )

        # end_index_off_peak
        end_index_off_peak_match = re.search(r"Heurescreuses \d+ (\d+)", substring)

        end_index_off_peak = (
            end_index_off_peak_match.group(1) if end_index_off_peak_match else None
        )

        # start_index_peak
        start_index_peak_match = re.search(r"Heurespleines (\d+) \d+", substring)

        start_index_peak = (
            start_index_peak_match.group(1) if start_index_peak_match else None
        )

        # end_index_peak
        end_index_peak_match = re.search(r"Heurespleines \d+ (\d+)", substring)

        end_index_peak = end_index_peak_match.group(1) if end_index_peak_match else None

        # start_date
        start_date_match = re.search(
            r"Du(\d\d\/\d\d\/\d\d\d\d)au\d\d\/\d\d\/\d\d\d\d", substring
        )

        start_date = (
            format_date(start_date_match.group(1)) if start_date_match else None
        )

        # end_date
        end_date_match = re.search(
            r"Du\d\d\/\d\d\/\d\d\d\dau(\d\d\/\d\d\/\d\d\d\d)", substring
        )

        end_date = format_date(end_date_match.group(1)) if end_date_match else None

        # off_peak_rate
        off_peak_rate_match = re.search(
            r"Heurescreuses \d+ \d+ \d+ ([0-9,]+) [0-9,]+ [0-9,]+", substring
        )

        off_peak_rate = (
            float(off_peak_rate_match.group(1).replace(",", "."))
            if off_peak_rate_match
            else None
        )

        # peak_rate
        peak_rate_match = re.search(
            r"Heurespleines \d+ \d+ \d+ ([0-9,]+) [0-9,]+ [0-9,]+", substring
        )

        peak_rate = (
            float(peak_rate_match.group(1).replace(",", "."))
            if peak_rate_match
            else None
        )

        return {
            "bill_id": bill_id,
            "start_index_off_peak": start_index_off_peak,
            "end_index_off_peak": end_index_off_peak,
            "start_index_peak": start_index_peak,
            "end_index_peak": end_index_peak,
            "start_date": start_date,
            "end_date": end_date,
            "off_peak_rate": off_peak_rate,
            "peak_rate": peak_rate,
        }

    with pdfplumber.open(file) as pdf:
        left_panel_info = get_left_panel_info(pdf.pages[0])

        for page in pdf.pages:
            file_content += page.extract_text()

    # id (generating the db id here is just handy)
    id = uuid.uuid4()

    # bill_number
    bill_number_match = re.search(
        r"Votrefacturedu\d\d/\d\d/\d\d\d\dN°(\d+)", file_content
    )

    bill_number = bill_number_match.group(1) if bill_number_match else None

    # season
    # ???

    # vat_free_cost
    vat_free_cost_match = re.search(r"TotalHorsTVA ([0-9,]+)€", file_content)

    vat_free_cost = (
        float(vat_free_cost_match.group(1).replace(",", "."))
        if vat_free_cost_match
        else None
    )

    # vat_cost
    vat_cost_match = re.search(r"Lieudeconsommation TVA ([0-9,]+)€", file_content)

    vat_cost = (
        float(vat_cost_match.group(1).replace(",", ".")) if vat_cost_match else None
    )

    # overpayment
    overpayment_match = re.search(
        r"Déductiondesprélèvementseffectués (-?[0-9,]+)€", file_content
    )

    overpayment = (
        -float(overpayment_match.group(1).replace(",", "."))
        if overpayment_match
        else None
    )

    # total_cost
    total_cost_match = re.search(
        r"Régularisationdevotreéchéancier ([0-9,]+)", file_content
    )

    total_cost = (
        float(total_cost_match.group(1).replace(",", ".")) if total_cost_match else None
    )

    # general_vat_rate
    general_vat_rate_match = re.search(
        r"TaxesurlaConsommationFinaled’Electricité\(TCFE\) [0-9,]+ [0-9,]+ [0-9,]+ ([0-9,]+)",
        file_content,
    )

    general_vat_rate = (
        float(general_vat_rate_match.group(1).replace(",", "."))
        if general_vat_rate_match
        else None
    )

    # energy_vat_rate
    energy_vat_rate_match = re.search(
        r"ContributionTarifaired’AcheminementElectricité\(CTA\) [0-9,]+ ([0-9,]+)",
        file_content,
    )

    energy_vat_rate = (
        float(energy_vat_rate_match.group(1).replace(",", "."))
        if energy_vat_rate_match
        else None
    )

    # bill_periods
    bill_period_matches = re.finditer(
        r"Du\d\d\/\d\d\/\d\d\d\dau\d\d\/\d\d\/\d\d\d\d\d\dkVA", file_content
    )

    bill_periods = []

    for match in bill_period_matches:
        bill_period = get_bill_period_info(match, file_content, id)
        bill_periods.append(bill_period)

    return {
        "id": id,
        "bill_number": bill_number,
        "vat_free_cost": vat_free_cost,
        "vat_cost": vat_cost,
        "overpayment": overpayment,
        "total_cost": total_cost,
        "general_vat_rate": general_vat_rate,
        "energy_vat_rate": energy_vat_rate,
        "address": left_panel_info["address"],
        "client_name": left_panel_info["client_name"],
        "client_number": left_panel_info["client_number"],
        "account_number": left_panel_info["account_number"],
        "contract_type": left_panel_info["contract_type"],
        "delivery_point_number": left_panel_info["delivery_point_number"],
        "power_kva": left_panel_info["power_kva"],
        "off_peak_hours": left_panel_info["off_peak_hours"],
    }, bill_periods


def store(bill, bill_periods):
    def gen_sql(table, rows_list):
        if not rows_list:
            raise ValueError("rows_list is empty")

        # All rows must have the same keys
        cols = list(rows_list[0].keys())
        str_cols = ", ".join(cols)

        # Build value placeholders: (%(col)s_1, %(col)s_2 ...)
        blocks = []
        params = {}
        for i, row in enumerate(rows_list):
            block = []
            for col in cols:
                key = f"{col}_{i}"
                block.append(f"%({key})s")
                params[key] = row[col]
            blocks.append(f"({', '.join(block)})")

        sql = f"INSERT INTO {table} ({str_cols}) VALUES {', '.join(blocks)};"
        return sql, params

    bill_sql, bill_params = gen_sql("bills", [bill])

    bill_periods_sql, bill_periods_params = gen_sql("bill_periods", bill_periods)

    with psycopg.connect(
        host="postgres",
        dbname=os.environ.get("POSTGRES_DB"),
        user=os.environ.get("POSTGRES_USER"),
        password=os.environ.get("POSTGRES_PASSWORD"),
    ) as conn:
        with conn.cursor() as cur:
            cur.execute(bill_sql, bill_params)
            cur.execute(bill_periods_sql, bill_periods_params)


args = parse_args()

bill, bill_periods = parse_pdf(args.type, args.file)

print(bill, bill_periods)

store(bill, bill_periods)
